- Some functions in software systems need to be applied at multiple points, but not be explicitly called from multiple
points in the code. Examples: Logging, Security, and Transaction Management. These types of functions that span multiple
points are called "cross-cutting concerns".

- Inheritance and Delegation have been used before to reuse common functionality, but Aspects are a better alternative.

- AOP Jaragon
  * Advice -> the job of an aspect, definint "what" and "when" of an asepct, using 5 different kinds, Before, After,
  After-returning, After-invoking, Around
  * Join Points -> a point in the execution of the application where an aspect can be plugged-in
  * Pointcuts -> narrow down the number of join points advised by an aspect. These define "where".
  * Aspects -> the merger of advice and pointcuts, everything comes together, what is des, where it does it, and when
  it is done.
  * Introductions -> allows the addition of new methods or attributes to existing classes
  * Weaving -> the process of applying aspects to a target object to create a new proxied object. Aspects are woven
  into the target object at the specified join points. This can happen at different points in an object's lifetime:
  Compile time, Class-Load time, or Runtime

- Spring's support for AOP comes in four styles
  1) Classic Spring proxy-based AOP (not covered)
  2) Pure-POJO aspects
  3) @AspectJ annotation-driven aspects
  4) Injected AspectJ aspects
  
- All the advice you create in Spring is written in a standard Java class. Pointers can be specified in annotations or
in XML Configuration

- Spring aspects are woven into Spring beans at runtime by wrapping them with a proxy class.

- Spring only supports method joinpoints, in contrast to other frameworks that support field and constructor joinpoints
as well

- In Spring, pointcuts are defined with AspectJ's pointcut expression language.

- The following are the supported operations (note: only execution actually performas matches, all the other contrain the
pointcuts' reach): args(), @args(), execution(), this(), target(), @target(), within(), @within(), @annotation.

- In addition to those designators, the bean() designator can be used to identify beans by ID in a pointcut expression.

- The chapter shows a cool example of creating a Performance class that has a perform method. The Aspect is created in an
Audience class and is used to execute methods on either side, before/after/around the perform method(). I didn't take too
many notes since I will learn the syntax by doing it.

- Using an "introduction", aspects can attach new methods to Spring beans. Spring aspects are proxies that implement the
same interface as the beans they wrap. In addition to implementing those interfaces, the proxy can be exposed to new
interfaces. When a method on the introduced interface is called, the proxy delegates the call to some other object that
provides the implementation of the new interface, providing a bean whose implementation is split acorss multiple classes.

- Another secion rehashes the above functionality with XML.

- The last section addresses limitations of AOP and introduces more power with AspectJ.
