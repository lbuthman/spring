In Spring, objects aren't responsible for finding or creating the other objects they need to do their jobs. The
container gives them the references they need to collaborate with each other. Wiring -> DI

Auto-Wire Beans
  - Attacked from two angles - Component Scanning and Autowiring
  - The @Component annotation in a class tells Spring to create a bean for the class. But this type of Component
  Scanning is not turned on by default; code must be written to explicitly set this configuration. This is done in
  a separate class with the @ComponentScan and @Configuration annotations used. This can also be accomplished in
  XML <context: component-scan>
  - The package(s) used can be set but will default to the current package if not specified.
  - The Test exmaple in the book used a pre-configured JUnit context reference, @RunWith, @ContextConfiguration,
  @Autowired, and @Test annotations.
  - All beans in a Spring application context are given an ID, this can be default or specified @Component("yourid")
  - Specify the scanned package with @ComponentScan("pkgname"). This allows code to live in separate packages
  like it should. A bit more explicitly, @ComponentScan(basePackages="pkgname", ...) can be used and can refer to
  multiple packages. This configuration uses a string and is therefore not type same if a package name is refactored.
  Another way is to specify classes, @ComponentScan(basePackageClasses={ClassName.class, ...})
  - Autowiring lets Spring automatically satisfy the beans dependencies; this is accomplished with the @Autowired
  annotation.
  - In a class, a constructor is annotated with @Autowired which lets Spring know that it should instantiate and 
  pass it to the assigned bean.
  - Autowiring can be accomplished with javax.inject.Inject, @Inject annotation. Not sure what the differences are
  between it and @Autowired.
  
Java Configuration Wiring
  - The @Configuration annotation identifies the class as a configuration class and that it will provide details
  on the beans that need to be created for the Spring application context.
  - Instead of using @ComponentScan, we now turn to a method that will reurn the desired type instance for the
  dependency. Then we can annotate that with @Bean.
  - Once again, we can specify the id with @Bean(name="idname") notation.
  - Because this is done with Java, the instance can be created in whatever way is desired via Java code.
  - To wire an Object with another Bean, again we can use the @Bean annotation. An example is for a constructor to
  be returned with the required parameter dependency. Spring will intercept this call and ensure the bean method
  is called rather than invoking the constructor again.
  
XML Wiring
  - For Java Configuration Wiring, we created a class, for XML Wiring we need to create an XML file rooted with
  a <beans> element. Certain syntax is required which can be found in the book.
  - To declare a bean, use the <bean> element - <bean class="path"/> and provide an id with id="idname"
  - Tip: only name a bean if it will specifically used later.
  - XML beans are created by calling the classes default constructor by default.
  - There is no type checking or compile-time verification since classes are named with Strings.
  - In addition to the class attribute in the bean element, we can also use <constructor-arg> and c-namespace. The
  <constructor-arg ref=""> allows the specification of a non-default constructor with required parameters. The 
  ref uses the id of the bean declared in the elsewhere. To use the c-namespace, a schema needs to be declared in
  the <beans> element. From there, a normal <bean> is used with c:(prefix)abc(constructor arg name)-ref="idbean"
  -> c:cd-ref="compactDisc"/>. Alternatively, the parameter can be refered to by position instead of name, 
  -> c:_0-ref="compactDisc"/>. The underscore is required since XML doesn't allow numeric prefixes. If there is only
  one parameter, the underscore will suffice
  - XML wiring can be done with literal values to construct more general objects, using constructor-arg value="value"
  syntax inside a <bean class="class"> element. The implementation is very similar for c-namespace.
  - A <null/> can be passed to a constructor if needed.
  - For a Collection parameter, list items can be specified with <list><value> tags. In addition, a list of object
  references can be passed with <list><ref bean="">. <set> is a valid tag for sets. There is no way to implment
  this with a c-namespace.
  - The author generally favors Constructor Injection for hard dependencies and Property Injection for optional ones.
  - For property injection, we can use <bean><property name="" ref="">. An alternative is the p-namespace, which
  requires a schema declaration like the c-namespace. The syntax is p:(propertyname)-ref="idbean" ->
  p:compactDisk-ref="compactDisc"/>
  - Property values can be set with literal values like constructors, <property name="propname" value="value"> and
  lists/sets similarly as well.
  - The util-namespace can be used to simplify beans. First specify the schema in <beans>, then use the <util> tag.
  One example is <util:list><value>
  
Mixed Configuration Wiring
  - For autowiring, it doesn't matter where the bean to be wired comes from.
  - To bring beans together from a Java Configuration file, use @Import(ClassConfig.class) and import the class
  path for Import. If the configuration is specified in XML, use @ImportResource("classpath.xml") with the
  imported ImportResource class path.
  - To bring in beans from XML, use the <import> tag. This only works with other XML resources though. To import a
  Java Configuration in XML, use <bean class="">.
  - The author usually creates a "root configuration" that wires together JavaConfig and XML files on a higher 
  level and typically will use it to turn on Component Scanning.
